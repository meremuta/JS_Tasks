# JS_Tasks

Tasks on JavaScript

### 1. Custom Array.prototype.filter
   
У массивов есть встроенный метод filter, который создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
Реализуйте собственную функцию фильтрации массива, в следующем формате:
```js
/**
 * Кастомная реализация метода Array.prototype.filter
 * 
 * @param {Array} array - массив
 * @param {Function} filterFn - фильтрующая функция
 * @param {Boolean} inplace - флаг "модифицируем исходный массив или нет"
 * @returns {Array} - отфильтрованный массив
 */
function filter(array, filterFn, inplace = false) {
    // ваш код здесь
}
```
**Решение : [task1.js](https://github.com/meremuta/JS_Tasks/blob/main/task1.js)**

*Немного не поняла задачу, поэтому реализовала как поняла*

### 2. Ключи и свойства

Реализуйте функцию, которая получает на вход объект, а возвращает объект, в котором в качестве ключей указаны типы, встречающиеся в исходном объекте, а в качестве значений - как часто они встречались.

**Решение : [task2.js](https://github.com/meremuta/JS_Tasks/blob/main/task2.js)**


### 3. Больше никаких шуток про 1 + '1' === '11'

Напишите функцию `sum`, которая:

- Принимает два значения
- Проверяет, является ли каждый из них числом
- Если они оба числа, то возвращается их сумма
- Если левый операнд не является числом, то выкидывается ошибка "The left operand is not number"
- Если правый операнд не является числом, то выкидывается ошибка "The right operand is not number"
- Если оба операнда не являются числами, то выкидывается ошибка "Operands are not numbers"

**Решение : [task3.js](https://github.com/meremuta/JS_Tasks/blob/main/task3.js)**

### 4. CVS на минималках

Напишите функцию `getMinimalCVS`, которая будет выполнять роль CVS для некоторого массива.

Она должна принимать на вход массив и возвращать объект с четырьмя свойствами:

- `head` - функция, возвращающая последнюю версию массива
- `history` - функция, возвращаюся массив со всеми версиями массива
- `push` - функция, принимающая элемент и сохраняющая новую версию массива с добавленным элементом в конце
- `pop` - функция, сохраняющая новую версию массива без последнего элемента и возвращающая этот последний элемент

**Решение : [task4.js](https://github.com/meremuta/JS_Tasks/blob/main/task4.js)**

### 6. Hit Or Run

Вы пишите искусственный интеллект (ИИ) для одной пошаговой стратегии. 
ИИ в один момент времени может либо бить `hit`, либо бежать `run`.

Напишите функцию `hitOrRun`, которая:
* Принимает на вход два натуральных числа `a` и `b` (`a < b`)
* Генерирует рандомное число в промежутке `[a, b]`
* Проверяет, является ли оно простым
* Если является, то возвращает строку `run`
* Если не является, то возвращает строку `hit`

**Решение : [task6.js](https://github.com/meremuta/JS_Tasks/blob/main/task6.js)**

### 7. Case Converter

В одном веб-приложении весь код бэкенда пишется в [snake_case](https://developer.mozilla.org/en-US/docs/Glossary/Snake_case) (все слова в нижнем регистре и разделяются нижним подчёркиванием), а фронтенд - в [camelCase](https://developer.mozilla.org/en-US/docs/Glossary/Camel_case) (слова не разделяются, первое слово пишется в нижнем регистре, у каждого следующего слова первая буква в верхнем регистре, остальные - в нижнем).

Чтобы обеспечить корректную передачу данных с бэкенда на фронтенд необходимо написать функцию, которая принимает на вход строку в `snake_case` и превращает её в строку в `camelCase`.

**Решение : [task7.js](https://github.com/meremuta/JS_Tasks/blob/main/task7.js)**

### 8. Антиспам

Одной из важных составляющих многих почтовых антиспам-систем является анализ текста письма.
В частности, если в нём содержатся определённые ключевые слова, фразы и обороты, то с высокой долей вероятности он будет отнесён к спаму.

Реализуйте функцию простейшей проверки текста на спам. Она должна иметь следующий формат:

```js
/**
 * Принимает на вход текст письма и массив ключевых слов и проверяет,
 * содержится ли хотя бы одно из ключевых слов в этом тексте
 * 
 * @param {String} text - текст, проверяемый на спам
 * @param {String[]} keywords - массив ключевых слов
 * @returns {Boolean}
 */
function isSpam(text, keywords) {
    // ваш код здесь
}
```

**Решение : [task8.js](https://github.com/meremuta/JS_Tasks/blob/main/task8.js)**

### 9. The World!

Один из способов заставить страницу зависнуть - вызвать внутри функции бесконечный цикл.
Такая функция никогда не покинет стек вызовов, из-за чего браузер никогда не сможет вызвать функцию перерисовки страницы (или любую другую).

Но иногда такую функцию можно использовать и на благо, например, замораживать выполнение кода внутри функции на определённое время.

Напишите функцию, которая останавливает время и выводит в консоль сообщение о том, сколько осталось секунд до возобновления.
Она должна иметь следующий формат:

```js
/**
 * Останавливает время на определённое количество миллисекунд
 * 
 * @param {Number} ms - количество миллисекунд, на которое необходимо остановить время
 */
function theWorld(ms) {
    // ваш код здесь,
    // включая вывод в консоль сообщения "Time will continue running in <remaining_seconds_number>"
}
```

**Решение : [task9.js](https://github.com/meremuta/JS_Tasks/blob/main/task9.js)**

### 10. Задача с собеседования

Первой задачей на алгоритмическом собеседовании на должность фронтенд-разработчика обычно дают что-то несложное, для разминки.

Например, напишите функцию, которая:
* Получает на вход натуральное число
* Перемножает все цифры числа, до тех пор, пока оно не станет одноразрядным
* Возвращает итоговое одноразрядное число

**Решение : [task10.js](https://github.com/meremuta/JS_Tasks/blob/main/task10.js)**

